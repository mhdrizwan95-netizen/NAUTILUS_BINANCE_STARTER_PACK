{
  "findings": [
    {
      "id": "arch-round-step",
      "severity": "S1",
      "area": "arch",
      "file": "engine/core/order_router.py",
      "lines": "1392-1405",
      "evidence": "OrderRouterExt.place_entry() calls self.round_step(), but the class has no such method; AttributeError is swallowed and quantities remain unrounded.",
      "impact": "Step-size enforcement and min-notional guard are bypassed, so strategies can emit quantities that exchanges reject or execute at unintended sizes, eroding fill reliability and risk controls.",
      "fix": "Add round_step/round_tick helpers directly on OrderRouterExt (delegating to SPECS) and update callers to use them; collapse _MDAdapter to a thin facade or remove it.",
      "diff": "--- a/engine/core/order_router.py\n+++ b/engine/core/order_router.py\n@@\n class OrderRouterExt(OrderRouter):\n+    def round_step(self, symbol: str, qty: float) -> float:\n+        venue = symbol.split(\".\")[1] if \".\" in symbol else self._venue\n+        base = symbol.split(\".\")[0].upper()\n+        spec = (SPECS.get(venue) or {}).get(base)\n+        step = spec.step_size if spec else 0.0\n+        return _round_step(float(qty), float(step or 1e-6))\n+\n+    def round_tick(self, symbol: str, price: float) -> float:\n+        venue = symbol.split(\".\")[1] if \".\" in symbol else self._venue\n+        base = symbol.split(\".\")[0].upper()\n+        spec = (SPECS.get(venue) or {}).get(base)\n+        tick = getattr(spec, \"tick_size\", 0.0) if spec else 0.0\n+        return _round_tick(float(price), float(tick or 0.0))\n@@\n-            q_rounded = self.round_step(symbol, float(qty))\n+            q_rounded = self.round_step(symbol, float(qty))\n"
    },
    {
      "id": "arch-universe-cycle",
      "severity": "S2",
      "area": "arch",
      "file": "engine/universe/__init__.py",
      "lines": "80-99",
      "evidence": "engine.universe.last_prices() performs from engine.app import _price_map and router, creating a runtime circular dependency between the HTTP layer and domain utilities.",
      "impact": "Universe utilities cannot be reused or tested without importing the entire FastAPI app; cold starts risk ImportError when the app module is mid-initialization, and background workers cannot refresh universes without bringing up HTTP plumbing.",
      "fix": "Introduce a small engine.market_state module exposing price snapshots and router accessors that both engine.app and engine.universe can depend on, or pass the router/price map in as parameters to break the cycle.",
      "diff": "--- a/engine/universe/__init__.py\n+++ b/engine/universe/__init__.py\n@@\n-async def last_prices() -> Dict[str, float]:\n-    from engine.app import _price_map\n-    ...\n-        try:\n-            from engine.app import router as order_router\n-            out[s] = await order_router.get_last_price(f\"{s}.BINANCE\")\n+async def last_prices(price_map: Optional[Dict[str, float]] = None, router: Optional[Any] = None) -> Dict[str, float]:\n+    price_map = price_map or {}\n+    ...\n+        if router is not None:\n+            out[s] = await router.get_last_price(f\"{s}.BINANCE\")\n"
    },
    {
      "id": "arch-ops-leak",
      "severity": "S2",
      "area": "arch",
      "file": "engine/app.py",
      "lines": "3043-3074",
      "evidence": "FastAPI startup hooks import ops.governance_daemon and wire BracketGovernor directly from the ops package inside the trading engine module.",
      "impact": "Runtime coupling makes the execution engine depend on ops automation code paths; minimal exporter images or unit tests without ops dependencies now fail to import engine.app, hindering deploy permutations and least-privilege packaging.",
      "fix": "Move governance/bracket wiring behind an optional plug-in interface (e.g. engine.plugins) so ops features can register themselves without the core engine importing ops.* at import time.",
      "diff": "--- a/engine/app.py\n+++ b/engine/app.py\n@@\n-    try:\n-        from ops import governance_daemon\n-        await governance_daemon.initialize_governance()\n+    try:\n+        governance = plugin_registry.get(\"governance\")\n+        if governance:\n+            await governance.initialize()\n"
  ],
  "risk_rollup": {"S0": 0, "S1": 1, "S2": 2, "S3": 0},
  "tickets": [],
  "state": {
    "arch_modules": [
      "engine/app.py",
      "engine/core/order_router.py",
      "engine/universe/__init__.py",
      "ops/governance_daemon.py"
    ],
    "hotspots": [
      "OrderRouterExt lacks native rounding helpers; min-notional guard bypassed",
      "Universe utilities import engine.app, creating circular lifetime coupling",
      "ops governance wiring executes inside engine startup"
    ]
  }
}
