{
  "framework": {
    "root": "frontend",
    "stack": "React 18 + Vite + TypeScript + TanStack Query + Zustand + Framer Motion",
    "tests": {
      "unit": "vitest",
      "e2e": "playwright",
      "config": [
        "frontend/vitest.config.ts",
        "frontend/playwright.config.ts"
      ]
    },
    "liveFlags": [
      "VITE_WS_URL",
      "VITE_LIVE_OFF",
      "__NAUTILUS_DISABLE_PERSIST__"
    ]
  },
  "loop_sources": {
    "effects": [
      "frontend/src/App.tsx:62-246 (boot state, WS ingestion, config sync)",
      "frontend/src/components/forms/DynamicParamForm.tsx:40-59 (propagate form changes upstream)",
      "frontend/src/components/tabs/BacktestingTab.tsx:82-149,168-199 (strategy bootstrap, poll consumption)",
      "frontend/src/components/tabs/FundingTab.tsx:78-119 (runtime config hydrate)",
      "frontend/src/components/tabs/SettingsTab.tsx:61-116 (ops cred mirror + override hydrate)",
      "frontend/src/lib/websocket.ts:223-361 (session lifecycle + connection management)",
      "frontend/src/lib/hooks.ts:18-55 (polling timer loop)",
      "frontend/src/components/ui/sidebar.tsx:87-121 (keydown listener + controlled state)"
    ],
    "timers": [
      "frontend/src/App.tsx:70-75 (boot splash timeout)",
      "frontend/src/lib/hooks.ts:26-55 (setTimeout polling loop)",
      "frontend/src/lib/websocket.ts:104-161 (heartbeat interval/timeout, reconnect backoff)",
      "frontend/src/lib/security.ts:430-458 (30s threat scan interval)"
    ],
    "subscriptions": [
      "frontend/src/lib/websocket.ts:265-361 (WS manager shared across components)",
      "frontend/src/lib/monitoring.ts:206-214 (React Query cache subscription)",
      "frontend/src/components/ui/carousel.tsx:90-120 (Embla select/reInit events)",
      "frontend/src/components/ui/sidebar.tsx:102-117 (window keydown listener)"
    ]
  },
  "suspects": [
    {
      "id": "resolved_ws_metrics",
      "location": "frontend/src/App.tsx:216",
      "type": "fixed",
      "graph": "WebSocket metrics \u2192 stableHash guard \u2192 query cache only updates on structural change",
      "notes": "stableHash replaces JSON stringify; query cache updates are skipped unless merge returns new reference"
    },
    {
      "id": "resolved_backtesting_overrides",
      "location": "frontend/src/components/tabs/BacktestingTab.tsx:359",
      "type": "fixed",
      "graph": "DynamicParamForm \u2192 hashed guard \u2192 setOverrides only runs on new data",
      "notes": "setOverrides uses stableHash to prevent duplicate state writes"
    },
    {
      "id": "resolved_polling_identity",
      "location": "frontend/src/lib/hooks.ts:33",
      "type": "fixed",
      "graph": "usePolling tick \u2192 stableHash dedupe \u2192 setData only on changed payload",
      "notes": "hash guard ensures structurally identical objects skip state updates"
    }
  ],
  "top_loops": [
    "resolved_ws_metrics",
    "resolved_backtesting_overrides",
    "resolved_polling_identity"
  ],
  "instrumentation": {
    "render_counter": [
      "Add useRenderCounter to BacktestingTab and DynamicParamForm when overrides dialog open to verify settle time.",
      "Console.count inside App metrics effect keyed by summaryQueryKey to observe WS cadence vs render cadence.",
      "Wrap usePolling inside a dev flag that logs consecutive identical payloads that still trigger setData."
    ],
    "questions": [
      "Should metrics/health WS payloads flow through the Zustand realTimeData slice (already deduped) instead of writing into React Query every frame?",
      "Do overrides need a stable equality check (deep compare) before dispatching setOverrides to avoid redundant state writes?",
      "Would a structural comparator (deep-equal) be safer as usePolling default to prevent accidental loops in new consumers?"
    ]
  }
}